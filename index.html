<!doctype html>
<html lang="en">
<head>
  <title>Crickets</title>
  <script src="js/three.min.js"></script>
  <script src="js/jquery-1.9.0.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/ObjectLoader.js"></script>
  <meta charset="utf-8">
    
    
  <style>
    
    body{
      /* set margin to 0 and overflow to hidden, to go fullscreen */
      margin: 0;
      overflow: hidden;
    }
    
  </style>
</head>
<body>

<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">
    var convert = 2.0;
    
    // once everything is loaded, we run our Three.js stuff.
    $(function () {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,150,200);
	camera.lookAt(scene.position);

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();

        renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(200,200);
        var planeMaterial =    new THREE.MeshLambertMaterial({color: 0xffffff});
        var plane = new THREE.Mesh(planeGeometry,planeMaterial);
        plane.receiveShadow  = true;

        // rotate and position the plane
        plane.position.y = -0.5;
	plane.rotation.x = Math.PI / 2;

        // add the plane to the scene
        scene.add(plane);

        // create a cube
        var cubeGeometry = new THREE.CubeGeometry(4,4,4);
        var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.castShadow = true;

        // position the cube
        cube.position.x=0;
        cube.position.y=0;
        cube.position.z=2.0;

        // add the cube to the scene
        scene.add(cube);
        
        // load heart
        var heartModel = new THREE.JSONLoader();
        heartModel.load( "models/heart.js", function(heart){
        var heartMaterial = new THREE.MeshLambertMaterial();
        heartMaterial.color.setHex(0xc93c2d);
        heartMesh = new THREE.Mesh(heart, heartMaterial);
        scene.add(heartMesh);
        
        heartMesh.position.set(100, 50, -50);

        // add spotlight for the shadow
        var spotLight = new THREE.SpotLight( 0xffffff );
        spotLight.position.set(0,250,0);
        spotLight.castShadow = true;
        scene.add( spotLight );

        // add the output of the renderer to the html element
        $("#WebGL-output").append(renderer.domElement);

        // call the render function
        //var step=0;
        render();
        
        function render() {
          
          cubeAnimate();
          
          function cubeAnimate() {
            if (convert != 12.2) {
              
              cube.position.z += 0.3;
              convert = cube.position.z.toFixed(1);
              console.log(convert);
              
            }
            
            if (convert == 12.2) {
              //alert('yo');
            }
            
          }
          
            // bounce the sphere up and down
            //step+=0.04;
            /*if (cube.position.z == 2) {
              cubePosZ = Math.floor(cube.position.z);
              cubePosZ += 0.3;
              cube.position.z = cubePosZ;
              console.log(cube.position.z);
            }
            
            else{
              console.log("not 2!");
              
              console.log(cubePosZ);
              
              if (cubePosZ != 2.6) {
              cubePosZ += 0.3;
              //cube.position.z = cubePosZ;
              console.log(cubePosZ);
              }
              
            }
            console.log("out of loop!");*/
            //cubePosz = Math.floor(cube.position.z);
            //cube.position.z = Math.floor(cubePosz);
          
            // render using requestAnimationFrame
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }
        
    });
        
    });



</script>
</body>
</html>



