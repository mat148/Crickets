<!doctype html>
<html lang="en">
<head>
    <title>Crickets</title>
    <script src="js/three.min.js"></script>
    <script src="js/jquery-1.9.0.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/ObjectLoader.js"></script>
    <script src="js/tween.min.js"></script>
    <meta charset="utf-8">
    
    
    <style>
        body{
          /* set margin to 0 and overflow to hidden, to go fullscreen */
          margin: 0;
          overflow: hidden;
        }
    </style>
</head>
<body>
    <audio id="cricketsAudio" controls>
        <source src="music/TheCricketsHaveArthritis.mp3" type="audio/mpeg">
        Your browser doesn't support the audio element.
    </audio>

    <!-- Div which will hold the Output -->
    <div id="WebGL-output">
    </div>
    
    <script id="vertexShader" type="x-shader/x-vertex">

        varying vec2 vUv;

        void main()
        {
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    
    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform sampler2D texture;
        uniform vec3 color;

        varying vec2 vUv;

        void main()
        {
            vec3 tColor = texture2D( texture, vUv ).rgb;
            float a = (length(tColor - color) - 0.5) * 7.0;

        //      gl_FragColor = vec4(a, a, a, 1.0);
            gl_FragColor = vec4(tColor, a);
        }
    </script>
    
    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">
        // once everything is loaded, we run our Three.js stuff.
        var scene, camera, renderer, box, spline, counter, marker, pt;
        var music = document.getElementById("cricketsAudio");
        var video, videoImage, videoImageContext, videoTexture;
        var video2, videoImage2, videoImageContext2, videoTexture2;
        var heartMesh;
        var planeMesh;
        var up = new THREE.Vector3( -1, 0, 0 );
        var axis = new THREE.Vector3( );
        
        scene = new THREE.Scene();
        
        ChromaKeyMaterial = function (url, width, height, keyColor) {
            THREE.ShaderMaterial.call(this);

            video = document.createElement('video');
            video.loop = true;
            video.src = url;
            video.load();
            //video.play();

            var videoImage = document.createElement('canvas');
            if (window["webkitURL"]) document.body.appendChild(videoImage);
            videoImage.width = width;
            videoImage.height = height;

            var keyColorObject = new THREE.Color(keyColor);

            var videoImageContext = videoImage.getContext('2d');
            // background color if no video present
            videoImageContext.fillStyle = '#' + keyColorObject.getHexString();
            videoImageContext.fillRect(0, 0, videoImage.width, videoImage.height);

            var videoTexture = new THREE.Texture(videoImage);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;

            this.update = function () {
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    videoImageContext.drawImage(video, 0, 0);
                    if (videoTexture) {
                        videoTexture.needsUpdate = true;
                    }
                }
            }

            this.setValues({

                uniforms: {
                    texture: {
                        type: "t",
                        value: videoTexture
                    },
                    color: {
                        type: "c",
                        value: keyColorObject
                    }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,

                transparent: true
            });
        }
        
        ChromaKeyMaterial2 = function (url, width, height, keyColor) {
            THREE.ShaderMaterial.call(this);

            video2 = document.createElement('video');
            video2.loop = true;
            video2.src = url;
            video2.load();
            //video.play();

            var videoImage2 = document.createElement('canvas');
            if (window["webkitURL"]) document.body.appendChild(videoImage2);
            videoImage2.width = width;
            videoImage2.height = height;

            var keyColorObject = new THREE.Color(keyColor);

            var videoImageContext2 = videoImage2.getContext('2d');
            // background color if no video present
            videoImageContext2.fillStyle = '#' + keyColorObject.getHexString();
            videoImageContext2.fillRect(0, 0, videoImage2.width, videoImage2.height);

            var videoTexture = new THREE.Texture(videoImage2);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;

            this.update = function () {
                if (video2.readyState === video2.HAVE_ENOUGH_DATA) {
                    videoImageContext2.drawImage(video2, 0, 0);
                    if (videoTexture) {
                        videoTexture.needsUpdate = true;
                    }
                }
            }

            this.setValues({

                uniforms: {
                    texture: {
                        type: "t",
                        value: videoTexture
                    },
                    color: {
                        type: "c",
                        value: keyColorObject
                    }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,

                transparent: true
            });
        }
        
        ChromaKeyMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
        ChromaKeyMaterial2.prototype = Object.create(THREE.ShaderMaterial.prototype);

        var movieMaterial = new ChromaKeyMaterial('video/Comp1.webm', 654, 480, 000000);
        var movieMaterial2 = new ChromaKeyMaterial2('video/leftArm.webm', 654, 480, 000000);
        //var movieGeometry = new THREE.PlaneGeometry( 204, 150, 4, 4 );
        //var movie = new THREE.Mesh(movieGeometry, movieMaterial);
        
        init();

        render();

        function init() {
            a=0;
            b=0;
            c=0;

            music.controls = true;
            music.play();

            // create a scene, that will hold all our elements such as objects, cameras and lights.
            //

            // create a camera, which defines where we're looking at.
            var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
            var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
            camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
            scene.add(camera);
            camera.position.set( 0, 200, 120);
            camera.lookAt(scene.position);

            // add spotlight for the shadow
            var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
            directionalLight.position.set( 0, 3, 0 );
            scene.add( directionalLight );

            // create a render and set the size
            renderer = new THREE.WebGLRenderer();

            renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMapEnabled = true;

            //controls = new THREE.OrbitControls( camera, renderer.domElement );
            
            // = videoImage.getContext( '2d' );
            // background color if no video present
            //videoImageContext.fillStyle = '#000000';
            //videoImageContext.fillRect( 0, 0, 50, 50);

            // create the ground plane
            var floorGeometry = new THREE.PlaneGeometry( 204, 150, 4, 4 );
            //var floorMaterial =    new THREE.MeshLambertMaterial({color: 0xffffff});
            var floor = new THREE.Mesh(floorGeometry,movieMaterial);
            //plane.receiveShadow  = true;

            // rotate and position the plane
            floor.position.set(0,0,0);
            floor.rotation.set(-90,0,0);
            //movieMaterial.position.set(0,0,0);

            // add the plane to the scene
            scene.add(floor);
            
            // create the ground plane
            var floorGeometry2 = new THREE.PlaneGeometry( 204, 150, 4, 4 );
            var arm = new THREE.Mesh(floorGeometry2,movieMaterial2);
            //plane.receiveShadow  = true;

            // rotate and position the plane
            arm.position.set(50,0,0);
            arm.rotation.set(-90,0,0);
            //movieMaterial.position.set(0,0,0);

            // add the plane to the scene
            scene.add(arm);

            // load heart
            var heartModel = new THREE.JSONLoader();

            heartModel.load( "models/heart.js", function(heart)
            {   
                var heartMaterial = new THREE.MeshLambertMaterial();
                heartMaterial.color.setHex(0xc93c2d);
                heartMesh = new THREE.Mesh(heart, heartMaterial);
                scene.add(heartMesh);
                heartMesh.position.set(0,-23,0);
               heartMesh.rotation.set(-0.3,0,0);
            });

            // load plane
            var planeModel = new THREE.JSONLoader();

            planeModel.load( "models/plane.js", function(plane)
            {   
                var planeTexture = new THREE.ImageUtils.loadTexture( 'img/noise.jpg' );
                var planeMaterial = new THREE.MeshLambertMaterial({map: planeTexture});
                //planeMaterial.color.setHex(0xc93c2d);
                planeMesh = new THREE.Mesh(plane, planeMaterial);
                scene.add(planeMesh);
                planeMesh.position.set(0,-10,0);
                //planeMesh.scale.set(10,10,10);
                planeMesh.rotation.set(-0.3,0,0);
            });
            
            //skybox
            var skyGeometry = new THREE.SphereGeometry(3000, 60, 40);
            
            var skyTexture = new THREE.ImageUtils.loadTexture( 'img/Milkyway_BG4.jpg' );
            var skyMaterial = new THREE.MeshBasicMaterial( { map: skyTexture, side: THREE.DoubleSide} );
 
            
            skyBox = new THREE.Mesh(skyGeometry, skyMaterial);
            skyBox.scale.set(-1, 1, 1);
            //skyBox.rotation.order = 'XZY';
            skyBox.renderDepth = 1000.0;
            scene.add(skyBox);

            //background-image: url(img/Milkyway_BG.jpg);
            
            planeSplineSetUp();
            cameraSplineSetUp();

            // add the output of the renderer to the html element
            $("#WebGL-output").append(renderer.domElement);
        }

        function planeSplineSetUp(){
            // smooth my curve over this many points
            var numPoints = 100;

            //spline
            planeSpline = new THREE.SplineCurve3
            ([
                new THREE.Vector3( 0, 5.308, -18),
                new THREE.Vector3( 10.176, 7.993, -12.667),
                new THREE.Vector3( 16.398, 11.793, -3.171),
                new THREE.Vector3( 16.559, 14.307, 7.726),
                new THREE.Vector3( 11.454, 17.473, 16.751),
                new THREE.Vector3( 1.301, 20.306, 22.552),
                new THREE.Vector3( -10.402, 23, 21.229),
                new THREE.Vector3( -19.546, 23, 14.659),
                new THREE.Vector3( -30, 23, 0),
                new THREE.Vector3( -40, 23, -15),
                new THREE.Vector3( -50, 23, -30),
                new THREE.Vector3( -60, 23, -45),
                new THREE.Vector3( -70, 23, -60),
                new THREE.Vector3( -80, 23, -75),
                new THREE.Vector3( -90, 23, -90),
                new THREE.Vector3( -100, 23, -105),
                new THREE.Vector3( -110, 23, -120),
                new THREE.Vector3( -120, 25, -135)
            ]);

            var material = new THREE.LineBasicMaterial
            ({
                color: 0xff00f0,
            });

            var geometry = new THREE.Geometry();
            var splinePoints = planeSpline.getPoints(numPoints);

            for(var i = 0; i < splinePoints.length; i++){
                geometry.vertices.push(splinePoints[i]);  
            }

            var line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        function cameraSplineSetUp(){
            // smooth my curve over this many points
            var numPoints = 100;
            //spline
            cameraSpline = new THREE.SplineCurve3
            ([
                new THREE.Vector3( 0, 200, 120),
                new THREE.Vector3( -5.9, 200, 111.1),
                new THREE.Vector3( -11.8, 200, 102.2),
                new THREE.Vector3( -17.7, 200, 93.3),
                new THREE.Vector3( -23.6, 200, 84.4),
                new THREE.Vector3( -29.5, 200, 75.5),
                new THREE.Vector3( -35.4, 200, 66.6),
                new THREE.Vector3( -41.3, 200, 57.7),
                new THREE.Vector3( -47.2, 200, 48.8),
                new THREE.Vector3( -53.1, 200, 39.9),
                new THREE.Vector3( -59, 200, 31),
                new THREE.Vector3( -64.9, 200, 22.1),
                new THREE.Vector3( -70.8, 200, 13.2),
                new THREE.Vector3( -76.7, 200, 4.3),
                new THREE.Vector3( -82.6, 200, -4.6),
                new THREE.Vector3( -88.5, 200, -13.5),
                new THREE.Vector3( -94.4, 200, -22.4),
                new THREE.Vector3( -100.3, 200, -31.3)
                
            ]);

            var material = new THREE.LineBasicMaterial
            ({
                color: 0xff00f0,
            });

            var geometry = new THREE.Geometry();
            var splinePoints = cameraSpline.getPoints(numPoints);

            for(var i = 0; i < splinePoints.length; i++){
                geometry.vertices.push(splinePoints[i]);  
            }

            var line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        function render() {
            requestAnimationFrame(render);
            movieMaterial.update();
            movieMaterial2.update();
            renderer.render(scene, camera);
            
            //checkMusicTime();
            
            if(Math.floor(music.currentTime) == 3)
                {
                    video.play();
                    video2.play();
                }

                if(Math.floor(music.currentTime) >= 9)
                {
                    setUpTween();
                }

                if(Math.floor(music.currentTime) >= 12)
                {   
                    attachPlane();
                }
                
                if(Math.floor(music.currentTime) >= 15)
                {
                    attachCam();
                }
        }

        function setUpTween() {
            var heartInc = 3;
            
            if(Math.floor(heartMesh.position.y) >= 23)
            {
                
            }
            
            else if ( heartInc <= 3 ) {
                //console.log(Math.floor(heartMesh.position.y));
                heartMesh.position.y += (1/heartInc);
                heartInc += 0.005;
            } 
            else {
                heartInc = 0;
            }

        }
        
        counter1 = 0;
        var t = 0;
        function attachPlane() {
            
            //console.log(planeMesh.y);
            
            if(planeMesh.position.y >= 25)
            {
            }
            
            else if ( counter1 <= 1 ) {
                planeMesh.position = planeSpline.getPoint( counter1 );
                planeMesh.rotation = planeSpline.getTangent( counter1 );
                counter1 += 2;


                // set the marker position
                pt = planeSpline.getPoint( t );
                planeMesh.position.set( pt.x, pt.y, pt.z );

                // get the tangent to the curve
                tangent = planeSpline.getTangent( t ).normalize();

                // calculate the axis to rotate around
                axis.crossVectors( up, tangent ).normalize();

                // calcluate the angle between the up vector and the tangent
                radians = Math.acos( up.dot( tangent ) );

                // set the quaternion
                planeMesh.quaternion.setFromAxisAngle( axis, radians );

                t = (t >= 1) ? 0 : t += 0.005;
            } 
            
            else {
                counter1 = 0;
            }

        }
        
        counter2 = 0;
        function attachCam() {
            //console.log(Math.floor(camera.position.x));
            if(Math.floor(camera.position.x) <= -100.3)
            {
                
            }
            
            else if ( counter2 <= 1 ) {
                console.log(counter2);
                camera.position = cameraSpline.getPoint( counter2 );
                counter2 += 0.005;

                // set the marker position
                //pt = cameraSpline.getPoint( t );
                //scamera.position.set( pt.x, pt.y, pt.z );
            } 
            
            else {
                counter2 = 0;
            }
        }
</script>
</body>
</html>



