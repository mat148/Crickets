<!doctype html>
<html lang="en">
<head>
    <title>Crickets</title>
    <script src="js/three.min.js"></script>
    <script src="js/jquery-1.9.0.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/ObjectLoader.js"></script>
    <script src="js/tween.min.js"></script>
    <meta charset="utf-8">
    
    
    <style>
        body{
          /* set margin to 0 and overflow to hidden, to go fullscreen */
          margin: 0;
          overflow: hidden;
        }

        .heartClass{
          position.set(0,50,0);
        }
    </style>
</head>
<body>
    <audio id="cricketsAudio" controls>
        <source src="music/TheCricketsHaveArthritis.mp3" type="audio/mpeg">
        Your browser doesn't support the audio element.
    </audio>

    <!-- Div which will hold the Output -->
    <div id="WebGL-output">
    </div>

    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">
        // once everything is loaded, we run our Three.js stuff.
        var scene, camera, renderer, box, spline, counter, marker, pt;
        var music = document.getElementById("cricketsAudio");
        var video, videoImage, videoImageContext, videoTexture;
        var heartMesh;
        var planeMesh;
        var up = new THREE.Vector3( -1, 0, 0 );
        var axis = new THREE.Vector3( );

        init();

        render();

        function init() {
            a=0;
            b=0;
            c=0;

            music.controls = true;
            music.play();

            // create a scene, that will hold all our elements such as objects, cameras and lights.
            scene = new THREE.Scene();

            // create a camera, which defines where we're looking at.
            var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
            var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
            camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
            scene.add(camera);
            camera.position.set( 0, 200, 120);
            camera.lookAt(scene.position);

            // add spotlight for the shadow
            var spotLight = new THREE.SpotLight( 0xffffff );
            spotLight.position.set(-150,250,150);
            spotLight.castShadow = true;
            scene.add( spotLight );

            // create a render and set the size
            renderer = new THREE.WebGLRenderer();

            renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMapEnabled = true;

            controls = new THREE.OrbitControls( camera, renderer.domElement );
            
            // create the video element
            video = document.createElement( 'video' );
            video.src = "video/booktest.mp4";
            video.load(); // must call after setting/changing source
            //video.play();
            
            videoImage = document.createElement( 'canvas' );
            videoImage.width = 654;
            videoImage.height = 480;
            
            videoImageContext = videoImage.getContext( '2d' );
            // background color if no video present
            videoImageContext.fillStyle = '#000000';
            //videoImageContext.fillRect( 0, 0, 50, 50);
            videoTexture = new THREE.Texture( videoImage );
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            
            var movieMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: false, side:THREE.SingleSide } );

            // create the ground plane
            var floorGeometry = new THREE.PlaneGeometry( 204, 150, 4, 4 );
            //var floorMaterial =    new THREE.MeshLambertMaterial({color: 0xffffff});
            var floor = new THREE.Mesh(floorGeometry,movieMaterial);
            //plane.receiveShadow  = true;

            // rotate and position the plane
            floor.position.set(0,0,0);
            floor.rotation.set(-90,0,0);

            // add the plane to the scene
            scene.add(floor);

            // load heart
            var heartModel = new THREE.JSONLoader();

            heartModel.load( "models/heart.js", function(heart)
            {   
                var heartMaterial = new THREE.MeshLambertMaterial();
                heartMaterial.color.setHex(0xc93c2d);
                heartMesh = new THREE.Mesh(heart, heartMaterial);
                scene.add(heartMesh);
                heartMesh.position.set(0,-23,0);
               heartMesh.rotation.set(-0.3,0,0);
            });

            // load plane
            var planeModel = new THREE.JSONLoader();

            planeModel.load( "models/plane.js", function(plane)
            {   
                var planeMaterial = new THREE.MeshLambertMaterial();
                planeMaterial.color.setHex(0xc93c2d);
                planeMesh = new THREE.Mesh(plane, planeMaterial);
                scene.add(planeMesh);
                planeMesh.position.set(0,0,0);
                //planeMesh.scale.set(10,10,10);
                planeMesh.rotation.set(-0.3,0,0);
            });
            
            planeSplineSetUp();
            cameraSplineSetUp();

            // add the output of the renderer to the html element
            $("#WebGL-output").append(renderer.domElement);
        }

        function planeSplineSetUp(){
            // smooth my curve over this many points
            var numPoints = 100;

            //spline
            planeSpline = new THREE.SplineCurve3
            ([
                new THREE.Vector3( 0, 23, -18),
                new THREE.Vector3( 10, 23, -14),
                new THREE.Vector3( 17, 23, -5),
                new THREE.Vector3( 17, 23, 6),
                new THREE.Vector3( 11, 23, 18),
                new THREE.Vector3( -3, 23, 23),
                new THREE.Vector3( -20, 23, 15),
                new THREE.Vector3( -30, 23, 0),
                new THREE.Vector3( -40, 23, -15),
                new THREE.Vector3( -50, 23, -30),
                new THREE.Vector3( -60, 23, -45),
                new THREE.Vector3( -70, 23, -60),
                new THREE.Vector3( -80, 23, -75),
                new THREE.Vector3( -90, 23, -90),
                new THREE.Vector3( -100, 23, -105),
                new THREE.Vector3( -110, 23, -120),
                new THREE.Vector3( -120, 25, -135)
            ]);

            var material = new THREE.LineBasicMaterial
            ({
                color: 0xff00f0,
            });

            var geometry = new THREE.Geometry();
            var splinePoints = planeSpline.getPoints(numPoints);

            for(var i = 0; i < splinePoints.length; i++){
                geometry.vertices.push(splinePoints[i]);  
            }

            var line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        function cameraSplineSetUp(){
            // smooth my curve over this many points
            var numPoints = 100;
            //spline
            cameraSpline = new THREE.SplineCurve3
            ([
                new THREE.Vector3( 0, 200, 120),
                new THREE.Vector3( -5, 200, 113),
                new THREE.Vector3( -10, 200, 105),
                new THREE.Vector3( -15, 200, 98),
                new THREE.Vector3( -20, 200, 90),
                new THREE.Vector3( -25, 200, 83),
                new THREE.Vector3( -30, 200, 75),
                new THREE.Vector3( -35, 200, 68),
                new THREE.Vector3( -40, 200, 60),
                new THREE.Vector3( -45, 200, 53),
                new THREE.Vector3( -50, 200, 45),
                new THREE.Vector3( -55, 200, 38),
                new THREE.Vector3( -60, 200, 30),
                new THREE.Vector3( -65, 200, 23),
                new THREE.Vector3( -70, 200, 15),
                new THREE.Vector3( -70, 200, 8),
                new THREE.Vector3( -80, 200, 0),
                new THREE.Vector3( -85, 200, -7),
                new THREE.Vector3( -90, 200, -15),
                new THREE.Vector3( -95, 200, -22),
                new THREE.Vector3( -100, 200, -30),
                new THREE.Vector3( -105, 200, -37),
                new THREE.Vector3( -110, 200, -45),
                new THREE.Vector3( -115, 200, -52),
                new THREE.Vector3( -120, 200, -60),
                new THREE.Vector3( -125, 200, -67)
            ]);

            var material = new THREE.LineBasicMaterial
            ({
                color: 0xff00f0,
            });

            var geometry = new THREE.Geometry();
            var splinePoints = cameraSpline.getPoints(numPoints);

            for(var i = 0; i < splinePoints.length; i++){
                geometry.vertices.push(splinePoints[i]);  
            }

            var line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        function render() {
            requestAnimationFrame(render);
            renderer.render(scene, camera);
            checkMusicTime();
            
            if ( video.readyState === video.HAVE_ENOUGH_DATA ) 
            {
                videoImageContext.drawImage( video, 0, 0 );
                
                if ( videoTexture ) 
                    videoTexture.needsUpdate = true;
            }
        }
        
        function checkMusicTime()
            {
                if(Math.floor(music.currentTime) == 3)
                {
                    video.play();
                }

                if(Math.floor(music.currentTime) == 10)
                {
                    if(a == 0)
                    {
                        setUpTween();
                        a++;
                    }
                }

                if(Math.floor(music.currentTime) == 13)
                {   
                    if(b == 0)
                    {
                        setInterval(attachPlane, 8);
                        b++;
                    }
                }
                
                if(Math.floor(music.currentTime) == 15)
                {   
                    if(c == 0)
                    {
                        setInterval(attachCam, 25);
                        c++;
                    }
                } 
            }

        function setUpTween() {
            var heartInc = 3;
            //heartCurPosX = heartMeshPos.position.x;
            //heartCurPosY = heartMeshPos.position.y;

            heartInc += 0.000035;

            heartMesh.position.y += (1/heartInc);

            if (heartMesh.position.y >= 23) {
                heartMesh.position.y = 23;
                heartInc = 0.0;
            }

            requestAnimationFrame(setUpTween);

        }
        
        counter = 0;
        var t = 0;
        function attachPlane() {
            
            //console.log(planeMesh.y);
            
            if(planeMesh.position.y >= 25)
            {
            }
            
            else if ( counter <= 1 ) {
                planeMesh.position = planeSpline.getPoint( counter );
                planeMesh.rotation = planeSpline.getTangent( counter );
                counter += 0.005


                // set the marker position
                pt = planeSpline.getPoint( t );
                planeMesh.position.set( pt.x, pt.y, pt.z );

                // get the tangent to the curve
                tangent = planeSpline.getTangent( t ).normalize();

                // calculate the axis to rotate around
                axis.crossVectors( up, tangent ).normalize();

                // calcluate the angle between the up vector and the tangent
                radians = Math.acos( up.dot( tangent ) );

                // set the quaternion
                planeMesh.quaternion.setFromAxisAngle( axis, radians );

                t = (t >= 1) ? 0 : t += 0.002;
            } 
            
            else {
                counter = 0;
            }

        }
        
        counter = 0;
        function attachCam() {
            if(camera.position.x == -120)
            {
                
            }
            
            else if ( counter <= 1 ) {
                camera.lookAt(planeMesh.position);
                camera.position = cameraSpline.getPoint( counter );
                counter += 0.005
            } 
            else {
                counter = 0;
            }
        }
</script>
</body>
</html>



